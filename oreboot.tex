\documentclass[conference]{IEEEtran}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{oreboot}

\author{\IEEEauthorblockN{Ronald G Minnich}
\IEEEauthorblockA{\textit{Google} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{Ryan O'Leary}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}

}

\maketitle

\begin{abstract}
Oreboot is a fork of Coreboot in Rust. Language safety. GPLv2.
\end{abstract}

\begin{IEEEkeywords}
oreboot, firmware, coreboot
\end{IEEEkeywords}

\section{*Introduction}

Downstream fork of coreboot\cite{minnich2000linux}
Open-source and GPLv2
Rust
Absolutely no C code.
Small pieces of assembly where necessary (ex: initializing stack pointer)
Coreboot assembly code is very useful for these tricky bits
Jump to kernel as quickly as possible
Firmware contains no network stack, disk drivers, debug shells, …
Those features are provided by payloads such as LinuxBoot
Strict policy for accepting closed-source blobs
Only an issue for the x86 port
Current RISC-V ports are fully open-source


\section{*Survey of Current Open-Source Firmware}

U-boot (1999-)
LinuxBIOS (1999-2008)
Coreboot (2008-)
NERF (2016-)
Linuxboot (2017-)
u-bmc (2018-)
SlimBoot (2018-) [sort of, it’s a UEFI DXE]

-- Too much C and assembly code.

\section{*Language Choice}

\subsection{*Rust for Firmware}

In recent decades, we have seen a flourish of programming languages and great improvements to language design which provide better safety features and ease of development. Many of these new languages such as Go, Python, Java, ... are unsuitable for the lowest layer of firmware.

\begin{itemize}
    \item Dependence on OS environment (such as syscall interface, memory managment)
    \item Runtime (GC, green threads)
\end{itemize}

Yes there are non-standard "reduced" implementations (such as tinygo, micropython, ...) of these languages, but they are non-standard / non-mainstream. For this reason, C still dominates firmware. All mainstream C compilers (such as GCC, clang) will allow you to build software in a standalone mode suitable for firmware.

Rust was originally designed by MOzilla in 200x for writing web browsers. The goal of making them more performant and secure. Today, it is used in kernals (see Tock \cite{b1} and Redox \cite{b3}), embedded firmware (see ??), usermode applications (see ??), UEFI drivers (see ??) and elsewhere.

\subsection{*Rust Safety}

The Rust compiler offers a number of compile-time safety features not present in other languages. In this section, three features we found useful for firmware are highlighted:

\begin{itemize}
    \item Borrow Checker
        \begin{verbatim}
for i in xs {
  print(i);
  xs.push(7); // compile error since xs is immutably borrowed
}
        \end{verbatim}
    \item Memory-safe concurrency
    \item Printf \begin{quote}format!("Rust {} {}", 4, "firmware");\end{quote}
\end{itemize}

\section{*Architecture}

\subsection{*Boot Flow}

\begin{itemize}
    \item \textbf{Boot Blob}: Executes directly from flash
First instruction
Initialize CPU
Debug UART print “Welcome to Oreboot”
Setup SRAM/CAR
Find and jump to Rom Stage
A fair bit of assembly code
    \item \textbf{Rom Stage}: Executes directly from flash
Has very little ~30KiB-8MiB of SRAM/CAR. Not enough for Linux yet!
Initialize RAM
    \item \textbf{Payloader stage}: Has one job
Find, load and run a payload
The payloader has no drivers, storage drivers, USB stack, etc… This is a big complexity reduction compared to your classic coreboot.
    \item \textbf{LinuxBoot}: Linux + Initramfs (or another kernel of your choosing)
Kernel (not oreboot) can optionally load another kernel from the disk or network and kexec
    \item \textbf{OS}
\end{itemize}

\subsection{*Driver Model}

\begin{verbatim}
pub type Result<T> = core::result::Result<T, &'static str>;
pub const EOF: Result<usize> = Err("EOF");
pub const NOT_IMPLEMENTED: Result<usize> = Err("not implemented");

pub trait Driver {
	/// Initialize the device.
	fn init(&mut self) -> Result<()>;
	/// Positional read. Returns number of bytes read.
	fn pread(&self, data: &mut [u8], pos: usize) -> Result<usize>;
	/// Positional write. Returns number of bytes written.
	fn pwrite(&mut self, data: &[u8], pos: usize) -> Result<usize>;
	/// Shutdown the device.
	fn shutdown(&mut self);
}
\end{verbatim}

\section{*Use Cases}

\subsection{*RISCV - OpenTitan}

RISC-V rv32imc
Embedded, not Linux capable
Open-source design for a root-of-trust
No ASIC available yet
Oreboot current runs on:
Verilator
FPGA (Artix-7)
Currently trying to boot Tock kernel

\subsection{*ARM - u-BMC}

ARM11
BMC Platform
Open-source memory initialization code
Converted to .rs with a Go program
Bootblob
1. Initialize CPU
2. Initialize Bus
3. Initial UART Print
4. Initialize SRAM
Romstage
5. Memory init


\subsection{*x86}

We prefer all pieces of the firmware to be open-source; but can accept an ME and FSP binary blob for x86 architectures.
Blobs must be essential to boot the system and not provide any extraneous functionality which could not be implemented in Oreboot.
Blobs must be redistributable and are ideally available on GitHub.
Blobs must not be submitted to github.com/oreboot/oreboot. We prefer blobs to be submitted to github.com/oreboot/blobs, github.com/coreboot/blobs or some other GitHub repository.
The blobs must be in a binary format. No additional C code, assembly files or header files are acceptable.
Any compromises to the language safety features of Rust must be explicitly stated.


\section*{Acknowledgment}

TODO

\section*{References}
\bibliographystyle{unsrt}
\bibliography{oreboot}


\vspace{12pt}

\end{document}
