\documentclass[conference]{IEEEtran}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{oreboot}

\author{\IEEEauthorblockN{Ronald G Minnich}
\IEEEauthorblockA{\textit{Google} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{Ryan O'Leary}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}

}

\maketitle

\begin{abstract}
Oreboot is a fork of Coreboot in Rust. Language safety. GPLv2.
\end{abstract}

\begin{IEEEkeywords}
oreboot, firmware, coreboot
\end{IEEEkeywords}

\section{*Introduction}

Downstream fork of coreboot
Open-source and GPLv2
Rust
Absolutely no C code.
Small pieces of assembly where necessary (ex: initializing stack pointer)
Coreboot assembly code is very useful for these tricky bits
Jump to kernel as quickly as possible
Firmware contains no network stack, disk drivers, debug shells, …
Those features are provided by payloads such as LinuxBoot
Strict policy for accepting closed-source blobs
Only an issue for the x86 port
Current RISC-V ports are fully open-source


\section{*Survey of Current Open-Source Firmware}

U-boot (1999-)
LinuxBIOS (1999-2008)
Coreboot (2008-)
NERF (2016-)
Linuxboot (2017-)
u-bmc (2018-)
SlimBoot (2018-) [sort of, it’s a UEFI DXE]

-- Too much C and assembly code.

\section{*Language Choice}

\subsection{*Rust for Firmware}

In recent decades, we have seen a flourish of programming languages and great improvements to language design which provide better safety features and ease of development. Many of these new languages such as Go, Python, Java, ... are unsuitable for the lowest layer of firmware.

\begin{itemize}
    \item Dependence on OS environment (such as syscall interface, memory managment)
    \item Runtime (GC, green threads)
\end{itemize}

Yes there are non-standard "reduced" implementations (such as tinygo, micropython, ...) of these languages, but they are non-standard / non-mainstream. For this reason, C still dominates firmware. All mainstream C compilers (such as GCC, clang) will allow you to build software in a standalone mode suitable for firmware.

Rust was originally designed by MOzilla in 200x for writing web browsers. The goal of making them more performant and secure. Today, it is used in kernals (see Tock \cite{b1} and Redox \cite{b3}), embedded firmware (see ??), usermode applications (see ??), UEFI drivers (see ??) and elsewhere.

\subsection{*Rust Safety}

The Rust compiler offers a number of compile-time safety features not present in other languages. In this section, three features we found useful for firmware are highlighted:

\begin{itemize}
    \item Borrow Checker
        \begin{verbatim}
for i in xs {
  print(i);
  xs.push(7); // compile error since xs is immutably borrowed
}
        \end{verbatim}
    \item Memory-safe concurrency
    \item Printf \begin{quote}format!("Rust {} {}", 4, "firmware");\end{quote}
\end{itemize}

\section{*Architecture}

\subsection{*Boot Flow}

\subsection{*Driver Model}

\section{*Use Cases}

\subsection{*RISCV - OpenTitan}

\subsection{*ARM - u-BMC}

\subsection{*x86}

\section*{Acknowledgment}

TODO

\section*{References}

TODO


\vspace{12pt}

\end{document}
